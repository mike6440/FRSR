#! /usr/bin/perl -X
#use strict; use warnings;

#========== FRSR V3 ===============================================================
#Call: ./InterpFrsrPacket.pl 

use lib "$ENV{DAQLIB}";
use perltools::MRtime;

$strin=shift();
$ix = index($strin,'*');
$strin=substr($strin,0,$ix+3);
print"$strin\n";
#$strin='$GPRMC,040053,A,3551.0194,N,10616.3562,W,000.0,188.4,080817,>>,H<W8,BMBM,lPnP,00D050=0>0=090,00D050607020=0,00N0,*76';
#$strin='$FSR03,L,83B3,>N<N,bReR,00000000000000,00000000000010,00X?,*11';
#$strin='$FSR03,L,34.3,<<$GPRMC,040053,A,3551.0194,N,10616.3562,W,000.0,188.4,080817,>>,H<W8,BMBM,lPnP,00D050=0>0=090,00D050607020=0,00N0,*76';
$strin =~ s/^\s+//;
$strin =~ s/\s+$//;
print"strin = $strin\n";

# TEST LENGTH
my ($pktlen,$cc,$packetid,$mode,$shadow,$shadowthreshold,$ix,$i,$hms,$dmy);
my (@g1,@g2,@sw);
$pktlen=length($strin);
print"length=$pktlen\n";
$#sw = 23 * 7;

## CHKSUM TEST
$cc = NmeaChecksum( substr($strin,0,-2) );
printf"chksum=%s\n",substr($strin,-2);
printf"computed chksum=%s\n", $cc;
if ($cc ne substr($strin,-2)) {
	print"Checksum fails, skip\n";
} else {
		# time
	$i=index($strin,'<<');
	$hms=substr($strin,$i+9,6);
	$i=index($strin,'>>');
	$dmy=substr($strin,$i-7,6);
	#print"$hms   $dmy\n";
	$dtgps=datesec(substr($dmy,4,2)+2000,substr($dmy,2,2),substr($dmy,0,2),substr($hms,0,2),substr($hms,2,2),substr($hms,4,2));
	printf"%s\n",dtstr($dtgps,'csv');

	$ichar=1;
	# Header
	$packetid = substr($strin,$ichar,5);
	print"ID = $packetid\n";
	$ichar+=6;
	# Mode
	$mode=substr($strin,$ichar,1);
	print"Mode = $mode\n";
	$ichar+=2;
	# T1,T2
	$T1 = DecodePsuedoAscii2( substr($strin,$ichar,2) )/10-20;
	$ichar+=2;
	$T2 = DecodePsuedoAscii2( substr($strin,$ichar,2) )/10-20;
	$ichar+=3;
	printf"T1 = %.1f   T2 = %.1f\n",$T1,$T2;
	# pitch1, pitch2
	$pitch1 = DecodePsuedoAscii2( substr($strin,$ichar,2) )/100-20;
	$ichar+=2;
	$pitch2 = DecodePsuedoAscii2( substr($strin,$ichar,2) )/100-20;
	$ichar+=3;
	printf"pitch1 = %.2f   pitch2 = %.2f\n",$pitch1,$pitch2;
	# roll1, roll2
	$roll1 = DecodePsuedoAscii2( substr($strin,$ichar,2) )/100-20;
	$ichar+=2;
	$roll2 = DecodePsuedoAscii2( substr($strin,$ichar,2) )/100-20;
	$ichar+=3;
	printf"roll1 = %.2f   roll2 = %.2f\n",$roll1,$roll2;
	# global 1
	$ix=$ichar;
	for($i=0; $i<7; $i++){
		push(@g1,DecodePsuedoAscii2( substr($strin,$ix,2) ) );
		$ix+=2;
	}
	for($i=0; $i<7; $i++){
		print"$g1[$i]  ";
	}
	print"\n";
	# global 2
	$ichar+=15;
	$ix=$ichar;
	for($i=0; $i<7; $i++){
		push(@g2,DecodePsuedoAscii2( substr($strin,$ix,2) ) );
		$ix+=2;
	}
	for($i=0; $i<7; $i++){
		print"$g2[$i]  ";
	}
	print"\n";
	# shadow, limit
	$ichar+=15;
	$shadow = DecodePsuedoAscii2( substr($strin,$ichar,2) )/10;
	$ichar+=2;
	$shadowthreshold = DecodePsuedoAscii2( substr($strin,$ichar,2) )/10;
	$ichar+=3;
	printf"shadow = %.1f   shadowthreshold = %.1f\n",$shadow,$shadowthreshold;
	# HIGH - SHADOW
	if($pktlen>300){
		# Sweep chan 0
		$ix=$ichar; # first character
		for($ia=0; $ia<7; $ia++){
			for($ib=0; $ib<23; $ib++){
				$ic = $ia*23 + $ib; # array index
				$sw[$ic] = DecodePsuedoAscii2( substr($strin,$ix,2) );
				$ix+=2;
			}
			$ix++; # skip the comma
		}
		# print out sweeps
		for($ia=0; $ia<7; $ia++){
			for($ib=0; $ib<23; $ib++){
				$ic = $ia*23 + $ib; # array index
				print"$sw[$ic] ";
			}
			print"\n";
		}
	}
}

# 
print"end\n";
exit 0;

#=========================================================
#$GPRMC,190824,A,4737.0000,S,12300.0000,W,002.1,202.0,210210,019.0,W*62
sub NmeaChecksum
# $cc = NmeaChecksum($str) where $str is the NMEA string that starts with '$' and ends with '*'.
{
    my ($line) = @_;
    my $csum = 0;
    $csum ^= unpack("C",(substr($line,$_,1))) for(1..length($line)-2);
    return (sprintf("%2.2X",$csum));
}
#==========================================================================
sub DecodePsuedoAscii2
# input = 2 p.a. chars   output = decimal number
{
	my ($strin,$c1,$c2,$b1,$b2,$x);
	$strin=shift();
	#printf"In string = $strin  ";
	$c1 = substr($strin,0,1);
	$c2 = substr($strin,1,1);
	$b1 = ord( $c1 ) - 48;
	$b2 = ord($c2) - 48;
	$x = $b2*64+$b1;
	#print"  decode = $x\n";
	return $x;
}

